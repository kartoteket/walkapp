<template>
  <div class="group" style="text-align: center;">
    <img v-show="imagePreview" :src="imagePreview" class="img-preview" width="100">
    <input id="fileInput" class="fileinput" type="file" :class="{ 'fileinput--small' : imagePreview }" @change="uploadFile" accept="image/*" capture="camera">
    <label for="fileInput">
      <figure>
        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
            <path class="path1" d="M9.5 19c0 3.59 2.91 6.5 6.5 6.5s6.5-2.91 6.5-6.5-2.91-6.5-6.5-6.5-6.5 2.91-6.5 6.5zM30 8h-7c-0.5-2-1-4-3-4h-8c-2 0-2.5 2-3 4h-7c-1.1 0-2 0.9-2 2v18c0 1.1 0.9 2 2 2h28c1.1 0 2-0.9 2-2v-18c0-1.1-0.9-2-2-2zM16 27.875c-4.902 0-8.875-3.973-8.875-8.875s3.973-8.875 8.875-8.875c4.902 0 8.875 3.973 8.875 8.875s-3.973 8.875-8.875 8.875zM30 14h-4v-2h4v2z"></path>
        </svg>
      </figure>
      <span>{{fileInputButtonCaption}}</span>
    </label>
  </div>
</template>

<script>
/**
 * TODO Items:
 * 1. Remove all wrapping markup (input only), but preserve option for imagePreview and reative buttonCaption
 * 1. Progress Report
 * 2. Multiple Files
 * 3. Suport custom completion callback
 */
import EXIF from 'exif-js'
import dataURLtoBlob from 'blueimp-canvas-to-blob'

export default {
  name: 'image-uploader',

  props: {
    /**
     * An integer in pixels for the maximum width allowed for uploaded images, selected images with a greater width than this value will be scaled down before upload.
     * @default 1024
     * @type {Number}
     */
    maxWidth: {
      type: Number,
      default: 1024
    },

    /**
     * An integer in pixels for the maximum height allowed for uploaded images, selected images with a greater height than this value will be scaled down before upload.
     * @default 1024
     * @type {Number}
     */
    maxHeight: {
      type: Number,
      default: 1024
    },

    /**
     * TODO: Does not make sens to me
     * A float value in megapixels (MP) for the maximum overall size of the image allowed for uploaded images, selected images with a greater size than this value will be scaled down before upload. If the value is null or is not specified, then maximum size restriction is not applied
     * @default null
     * @type {Number}
     */
    maxSize: {
      type: Number,
      default: null
    },

    /**
     * A float between 0 and 1.00 for the image quality to use in the resulting image data, around 0.9 is recommended.
     * @default 1.00
     * @type {Number}
     */
    quality: {
      type: Number,
      default: 1.00
    },

    /**
     * Allows scaling down to a specified fraction of the original size. (Example: a value of 0.5 will reduce the size by half.) Accepts a decimal value between 0 and 1.
     * @default null
     * @type {Number}
     */
    scaleRatio: {
      type: Number,
      default: null
    },

    /**
     * A boolean flag, if true then EXIF information from the image is parsed and the image is rotated correctly before upload. If false, then no processing is performed, and unwanted image flipping can happen.
     * @default true
     * @type {Boolean}
     */
    autoRotate: {
      type: Boolean,
      default: true
    },

    /**
     * Sets the desired format for the returned image. Available formats are
     * 'string' (base64), verbose (object) or 'blob' (object)
     * @default {base64}
     * @type {String}
     */
    outputFormat: {
      type: String,
      default: 'string'
    },

    /**
     * [debug description]
     * @default false
     * @type {Boolean}
     */
    debug: {
      type: Boolean,
      default: false
    }

  },

  data () {
    return {
      imagePreview: null
    }
  },

  computed: {
    fileInputButtonCaption: function () {
      return this.imagePreview ? 'Endre bildet…' : 'Legg til et bilde…'
    }
  },

  methods: {

    /**
     * Get file from input
     * @param  {object} event
     */
    uploadFile (e) {
      var file = e.target.files && e.target.files.length ? e.target.files[0] : null
      if (file) {
        this.emitLoad()
        this.handleFile(file, this.emitComplete)
      }
    },

    /**
     * Emit event with output
     * @param  {mixed} output   the resized image. type can be simple dataUrl string, verbose object or Blob instance
     * @return {[type]}        [description]
     */
    emitEvent (output) {
      this.$emit('input', output)
      this.$emit('change', output)
    },

    emitLoad () {
      this.$emit('onUpload')
    },

    emitComplete () {
      this.$emit('onComplete')
    },

    /**
     * Handels the file manipulation on upload
     * @param  {File}     file The current original uploaded file
     * @param  {function} completionCallback Not implemted yet
     * @return {}         nada
     */
    handleFile (file, completionCallback) {
      this.currentFile = file
      var that = this
      var img = document.createElement('img')
      var reader = new FileReader()

      reader.onload = function (e) {
        img.src = e.target.result
        img.onload = function () {
          // Rotate image first if required
          if (that.autoRotate) {
            if (this.debug) {
              console.log('ImageUploader: detecting image orientation...')
            }
            if ((typeof EXIF.getData === 'function') && (typeof EXIF.getTag === 'function')) {
              EXIF.getData(img, function () {
                var orientation = EXIF.getTag(this, 'Orientation')
                if (that.debug) {
                  console.log('ImageUploader: image orientation from EXIF tag = ' + orientation)
                }
                that.scaleImage(img, completionCallback, orientation)
              })
            } else {
              console.error('ImageUploader: can\'t read EXIF data, the Exif.js library not found')
              that.scaleImage(img, completionCallback)
            }
          }
        }
      }
      reader.readAsDataURL(file)
    },

    /**
     * Performance orientation and scalin logic
     * @param  {[type]} img                [description]
     * @param  {[type]} completionCallback [description]
     * @param  {[type]} orientation        [description]
     * @return {[type]}                    [description]
     */
    scaleImage (img, completionCallback, orientation) {
      var canvas = document.createElement('canvas')
      canvas.width = img.width
      canvas.height = img.height
      var ctx = canvas.getContext('2d')
      ctx.save()

      // Good explanation of EXIF orientation is here http://www.daveperrett.com/articles/2012/07/28/exif-orientation-handling-is-a-ghetto/
      var width = canvas.width
      var styleWidth = canvas.style.width
      var height = canvas.height
      var styleHeight = canvas.style.height
      if (typeof orientation === 'undefined') {
        orientation = 1
      }
      if (orientation) {
        if (orientation > 4) {
          canvas.width = height
          canvas.style.width = styleHeight
          canvas.height = width
          canvas.style.height = styleWidth
        }
        switch (orientation) {
          case 2:
            ctx.translate(width, 0)
            ctx.scale(-1, 1)
            break
          case 3:
            ctx.translate(width, height)
            ctx.rotate(Math.PI)
            break
          case 4:
            ctx.translate(0, height)
            ctx.scale(1, -1)
            break
          case 5:
            ctx.rotate(0.5 * Math.PI)
            ctx.scale(1, -1)
            break
          case 6:
            ctx.rotate(0.5 * Math.PI)
            ctx.translate(0, -height)
            break
          case 7:
            ctx.rotate(0.5 * Math.PI)
            ctx.translate(width, -height)
            ctx.scale(-1, 1)
            break
          case 8:
            ctx.rotate(-0.5 * Math.PI)
            ctx.translate(-width, 0)
            break
        }
      }
      ctx.drawImage(img, 0, 0)
      ctx.restore()

      // Let's find the max available width for scaled image
      var ratio = canvas.width / canvas.height
      var mWidth = Math.min(this.maxWidth, ratio * this.maxHeight)

      if ((this.maxSize > 0) && (this.maxSize < canvas.width * canvas.height / 1000)) {
        mWidth = Math.min(mWidth, Math.floor(Math.sqrt(this.maxSize * ratio)))
      }

      if (this.scaleRatio) {
        mWidth = Math.min(mWidth, Math.floor(this.scaleRatio * canvas.width))
      }

      if (this.debug) {
        console.log('ImageUploader: original image size = ' + canvas.width + ' X ' + canvas.height)
        console.log('ImageUploader: scaled image size = ' + mWidth + ' X ' + Math.floor(mWidth / ratio))
      }

      if (mWidth <= 0) {
        mWidth = 1
        console.warning('ImageUploader: image size is too small')
      }

      while (canvas.width >= (2 * mWidth)) {
        canvas = this.getHalfScaleCanvas(canvas)
      }

      if (canvas.width > mWidth) {
        canvas = this.scaleCanvasWithAlgorithm(canvas, mWidth)
      }

      var imageData = canvas.toDataURL('image/jpeg', this.quality)
      if (typeof this.onScale === 'function') {
        this.onScale(imageData)
      }

      // svale: juhu! Display and return the new image
      this.imagePreview = imageData
      // this.emitEvent(this.currentFile) // DEBUG
      this.emitEvent(this.formatOutput(imageData))

      // complete
      completionCallback()
      // this.performUpload(imageData, completionCallback)
    },

    scaleCanvasWithAlgorithm (canvas, maxWidth) {
      var scaledCanvas = document.createElement('canvas')
      var scale = maxWidth / canvas.width

      scaledCanvas.width = canvas.width * scale
      scaledCanvas.height = canvas.height * scale

      var srcImgData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height)
      var destImgData = scaledCanvas.getContext('2d').createImageData(scaledCanvas.width, scaledCanvas.height)

      this.applyBilinearInterpolation(srcImgData, destImgData, scale)

      scaledCanvas.getContext('2d').putImageData(destImgData, 0, 0)

      return scaledCanvas
    },

    /* eslint-disable camelcase */
    applyBilinearInterpolation (srcCanvasData, destCanvasData, scale) {
      function inner (f00, f10, f01, f11, x, y) {
        var un_x = 1.0 - x
        var un_y = 1.0 - y
        return (f00 * un_x * un_y + f10 * x * un_y + f01 * un_x * y + f11 * x * y)
      }
      var i, j
      var iyv, iy0, iy1, ixv, ix0, ix1
      var idxD, idxS00, idxS10, idxS01, idxS11
      var dx, dy
      var r, g, b, a
      for (i = 0; i < destCanvasData.height; ++i) {
        iyv = i / scale
        iy0 = Math.floor(iyv)
        // Math.ceil can go over bounds
        iy1 = (Math.ceil(iyv) > (srcCanvasData.height - 1) ? (srcCanvasData.height - 1) : Math.ceil(iyv))
        for (j = 0; j < destCanvasData.width; ++j) {
          ixv = j / scale
          ix0 = Math.floor(ixv)
          // Math.ceil can go over bounds
          ix1 = (Math.ceil(ixv) > (srcCanvasData.width - 1) ? (srcCanvasData.width - 1) : Math.ceil(ixv))
          idxD = (j + destCanvasData.width * i) * 4
          // matrix to vector indices
          idxS00 = (ix0 + srcCanvasData.width * iy0) * 4
          idxS10 = (ix1 + srcCanvasData.width * iy0) * 4
          idxS01 = (ix0 + srcCanvasData.width * iy1) * 4
          idxS11 = (ix1 + srcCanvasData.width * iy1) * 4
          // overall coordinates to unit square
          dx = ixv - ix0
          dy = iyv - iy0
          // I let the r, g, b, a on purpose for debugging
          r = inner(srcCanvasData.data[idxS00], srcCanvasData.data[idxS10], srcCanvasData.data[idxS01], srcCanvasData.data[idxS11], dx, dy)
          destCanvasData.data[idxD] = r

          g = inner(srcCanvasData.data[idxS00 + 1], srcCanvasData.data[idxS10 + 1], srcCanvasData.data[idxS01 + 1], srcCanvasData.data[idxS11 + 1], dx, dy)
          destCanvasData.data[idxD + 1] = g

          b = inner(srcCanvasData.data[idxS00 + 2], srcCanvasData.data[idxS10 + 2], srcCanvasData.data[idxS01 + 2], srcCanvasData.data[idxS11 + 2], dx, dy)
          destCanvasData.data[idxD + 2] = b

          a = inner(srcCanvasData.data[idxS00 + 3], srcCanvasData.data[idxS10 + 3], srcCanvasData.data[idxS01 + 3], srcCanvasData.data[idxS11 + 3], dx, dy)
          destCanvasData.data[idxD + 3] = a
        }
      }
    },

    getHalfScaleCanvas (canvas) {
      var halfCanvas = document.createElement('canvas')
      halfCanvas.width = canvas.width / 2
      halfCanvas.height = canvas.height / 2

      halfCanvas.getContext('2d').drawImage(canvas, 0, 0, halfCanvas.width, halfCanvas.height)

      return halfCanvas
    },

    /**
     * Sets the format otf the component output
     * @param  {string} imageData  dataUrl
     * @return {mixed}             Eithe simple dataUrl string, object with dataURl and metadata or blob
     */
    formatOutput (imageData) {
      if (this.outputFormat === 'blob') {
        return dataURLtoBlob(imageData)
      } else if (this.outputFormat === 'verbose') {
        return {
          dataUrl: imageData,
          name: this.currentFile.name,
          lastModified: this.currentFile.lastModified,
          lastModifiedDate: this.currentFile.lastModifiedDate
        }
      }

      // simple base 64 dataUrl string by default
      return imageData
    }
  },

  created () {
    if (this.debug) {
      console.log('Initialised ImageUploader')
    }
  }
}
</script>
